# File I/O in C with Cereal
## December 30 2016

I recently finished reading the book *The C Programming Language*, commonly referred to as "K&R". It’s my first exposure to the C language. I don’t intend to write many programs in C, but I wanted to learn about the low-level system interactions that it permits and relies on. As someone who didn't major in computer science, gaining knowledge of these low-level system interactions improves my understanding of things that I do in higher-level languages.

I am surprised and happy to know that talking to the operating system is actually quite simple conceptually and limited in scope. The only real things a program can do with the system are read and write files and request memory. I’m going to explain the basics of C’s `open` and `read` functions, which are the foundation of the library function `fopen`, and then give an analogy in terms of eating cereal.

The `read` function in C takes a *file descriptor*, a buffer (a pointer to a block of memory), and a quantity of bytes to read. The `open` function takes the name of a file and a `mode` and returns a file descriptor. For a program to consume data from a file, it first needs to open the file to get a file descriptor, and then read some of the data from that file and put it in a buffer so that the program can use it. The size of the buffer is up for discretion. If the buffer is small, the program will have a small memory footprint but may need to make many system calls to read more data from the file into the buffer. If the buffer is big, then the program will likely only need to make one call to get the data, but it will take up more room in memory. How can we visualize these system calls and buffers to better understand the mechanics of what’s going on? Let’s look at the cereal analogy.

You can think of the `open` function as going into the cabinet and choosing a box of cereal to open. You request the name of a cereal to open--say, “Coco Puffs"--and the cabinet returns you a box of Coco Puffs. This box isn’t very useful to you yet: Your parents don’t allow you to eat cereal straight out of the box. You must take some cereal out of the box and put it in a bowl before you can eat it. The bowl is the buffer that you’ll wind up “reading” cereal into. You must make another system call to the cabinet to get the bowl (a pointer) that will hold your cereal. Now you can request 2 cups of cereal from the box and put them in the bowl. This is the call to `read`. Keep in mind that the bowl must be large enough to hold the 2 cups of cereal, or else you will have a problem. If you decide you want to eat more cereal, you can make another system call to read more cereal, otherwise you can close the box and return it to the cabinet.

Now imagine if your bowl was the size of a shot glass and you could only retrieve 5 pieces of cereal at a time from the box. That would be super annoying! Likewise, what if your bowl was a 5-gallon jug? That would seem super wasteful to put your 2 cups of cereal into a giant 5-gallon jug that could have been filled with water! The size of the bowl is ideally just big enough to hold all the cereal you wish to eat, but not so big that you’re wasting space that could have been used for something else.

Hopefully this analogy helps paint a picture of the decisions that a program must make when reading data from a file. See if you can apply this simple example to other processes!
